/**
 * Generated by orval v7.11.2 🍺
 * Do not edit manually.
 * Blog Post API
 * API endpoints for the blog post application, supporting post management and comments.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  BadRequestResponse,
  BlogPostListResponse,
  BlogPostResponse,
  CommentsResponse,
  CreateCommentRequest,
  CreatePostRequest,
  GetBlogPostsParams,
  NotFoundResponse,
  UnauthorizedResponse
} from './schemas';

import { fetcher } from '../customFetch';




/**
 * Fetches a paginated list of blog posts for the home page.
 * @summary Get Blog Posts
 */
export const getGetBlogPostsUrl = (params?: GetBlogPostsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/posts?${stringifiedParams}` : `/posts`
}

export const getBlogPosts = async (params?: GetBlogPostsParams, options?: RequestInit): Promise<BlogPostListResponse> => {
  
  return fetcher<BlogPostListResponse>(getGetBlogPostsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetBlogPostsQueryKey = (params?: GetBlogPostsParams,) => {
    return [`/posts`, ...(params ? [params]: [])] as const;
    }

    
export const getGetBlogPostsQueryOptions = <TData = Awaited<ReturnType<typeof getBlogPosts>>, TError = BadRequestResponse>(params?: GetBlogPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlogPosts>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBlogPostsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBlogPosts>>> = ({ signal }) => getBlogPosts(params, { signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBlogPosts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBlogPostsQueryResult = NonNullable<Awaited<ReturnType<typeof getBlogPosts>>>
export type GetBlogPostsQueryError = BadRequestResponse


export function useGetBlogPosts<TData = Awaited<ReturnType<typeof getBlogPosts>>, TError = BadRequestResponse>(
 params: undefined |  GetBlogPostsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlogPosts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBlogPosts>>,
          TError,
          Awaited<ReturnType<typeof getBlogPosts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBlogPosts<TData = Awaited<ReturnType<typeof getBlogPosts>>, TError = BadRequestResponse>(
 params?: GetBlogPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlogPosts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBlogPosts>>,
          TError,
          Awaited<ReturnType<typeof getBlogPosts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBlogPosts<TData = Awaited<ReturnType<typeof getBlogPosts>>, TError = BadRequestResponse>(
 params?: GetBlogPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlogPosts>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Blog Posts
 */

export function useGetBlogPosts<TData = Awaited<ReturnType<typeof getBlogPosts>>, TError = BadRequestResponse>(
 params?: GetBlogPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlogPosts>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBlogPostsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Creates a new blog post.
 * @summary Create Blog Post
 */
export const getCreateBlogPostUrl = () => {


  

  return `/posts`
}

export const createBlogPost = async (createPostRequest: CreatePostRequest, options?: RequestInit): Promise<BlogPostResponse> => {
  
  return fetcher<BlogPostResponse>(getCreateBlogPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createPostRequest,)
  }
);}




export const getCreateBlogPostMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBlogPost>>, TError,{data: CreatePostRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createBlogPost>>, TError,{data: CreatePostRequest}, TContext> => {

const mutationKey = ['createBlogPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBlogPost>>, {data: CreatePostRequest}> = (props) => {
          const {data} = props ?? {};

          return  createBlogPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBlogPostMutationResult = NonNullable<Awaited<ReturnType<typeof createBlogPost>>>
    export type CreateBlogPostMutationBody = CreatePostRequest
    export type CreateBlogPostMutationError = BadRequestResponse | UnauthorizedResponse

    /**
 * @summary Create Blog Post
 */
export const useCreateBlogPost = <TError = BadRequestResponse | UnauthorizedResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBlogPost>>, TError,{data: CreatePostRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createBlogPost>>,
        TError,
        {data: CreatePostRequest},
        TContext
      > => {

      const mutationOptions = getCreateBlogPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Fetches the details of a single blog post by its ID.
 * @summary Get Single Blog Post
 */
export const getGetBlogPostByIdUrl = (id: string,) => {


  

  return `/posts/${id}`
}

export const getBlogPostById = async (id: string, options?: RequestInit): Promise<BlogPostResponse> => {
  
  return fetcher<BlogPostResponse>(getGetBlogPostByIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetBlogPostByIdQueryKey = (id?: string,) => {
    return [`/posts/${id}`] as const;
    }

    
export const getGetBlogPostByIdQueryOptions = <TData = Awaited<ReturnType<typeof getBlogPostById>>, TError = NotFoundResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlogPostById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBlogPostByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBlogPostById>>> = ({ signal }) => getBlogPostById(id, { signal });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBlogPostById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBlogPostByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getBlogPostById>>>
export type GetBlogPostByIdQueryError = NotFoundResponse


export function useGetBlogPostById<TData = Awaited<ReturnType<typeof getBlogPostById>>, TError = NotFoundResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlogPostById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBlogPostById>>,
          TError,
          Awaited<ReturnType<typeof getBlogPostById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBlogPostById<TData = Awaited<ReturnType<typeof getBlogPostById>>, TError = NotFoundResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlogPostById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBlogPostById>>,
          TError,
          Awaited<ReturnType<typeof getBlogPostById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBlogPostById<TData = Awaited<ReturnType<typeof getBlogPostById>>, TError = NotFoundResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlogPostById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Single Blog Post
 */

export function useGetBlogPostById<TData = Awaited<ReturnType<typeof getBlogPostById>>, TError = NotFoundResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlogPostById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBlogPostByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Updates an existing blog post by its ID.
 * @summary Update Blog Post
 */
export const getUpdateBlogPostUrl = (id: string,) => {


  

  return `/posts/${id}`
}

export const updateBlogPost = async (id: string,
    createPostRequest: CreatePostRequest, options?: RequestInit): Promise<BlogPostResponse> => {
  
  return fetcher<BlogPostResponse>(getUpdateBlogPostUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createPostRequest,)
  }
);}




export const getUpdateBlogPostMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBlogPost>>, TError,{id: string;data: CreatePostRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBlogPost>>, TError,{id: string;data: CreatePostRequest}, TContext> => {

const mutationKey = ['updateBlogPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBlogPost>>, {id: string;data: CreatePostRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateBlogPost(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBlogPostMutationResult = NonNullable<Awaited<ReturnType<typeof updateBlogPost>>>
    export type UpdateBlogPostMutationBody = CreatePostRequest
    export type UpdateBlogPostMutationError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse

    /**
 * @summary Update Blog Post
 */
export const useUpdateBlogPost = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBlogPost>>, TError,{id: string;data: CreatePostRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBlogPost>>,
        TError,
        {id: string;data: CreatePostRequest},
        TContext
      > => {

      const mutationOptions = getUpdateBlogPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Fetches all comments for a specific blog post.
 * @summary Get Post Comments
 */
export const getGetPostCommentsUrl = (id: string,) => {


  

  return `/posts/${id}/comments`
}

export const getPostComments = async (id: string, options?: RequestInit): Promise<CommentsResponse> => {
  
  return fetcher<CommentsResponse>(getGetPostCommentsUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetPostCommentsQueryKey = (id?: string,) => {
    return [`/posts/${id}/comments`] as const;
    }

    
export const getGetPostCommentsQueryOptions = <TData = Awaited<ReturnType<typeof getPostComments>>, TError = NotFoundResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostComments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPostCommentsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPostComments>>> = ({ signal }) => getPostComments(id, { signal });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPostComments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPostCommentsQueryResult = NonNullable<Awaited<ReturnType<typeof getPostComments>>>
export type GetPostCommentsQueryError = NotFoundResponse


export function useGetPostComments<TData = Awaited<ReturnType<typeof getPostComments>>, TError = NotFoundResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostComments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPostComments>>,
          TError,
          Awaited<ReturnType<typeof getPostComments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPostComments<TData = Awaited<ReturnType<typeof getPostComments>>, TError = NotFoundResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostComments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPostComments>>,
          TError,
          Awaited<ReturnType<typeof getPostComments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPostComments<TData = Awaited<ReturnType<typeof getPostComments>>, TError = NotFoundResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostComments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Post Comments
 */

export function useGetPostComments<TData = Awaited<ReturnType<typeof getPostComments>>, TError = NotFoundResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostComments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPostCommentsQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Creates a new comment on a specific blog post.
 * @summary Create Comment
 */
export const getCreateCommentUrl = (id: string,) => {


  

  return `/posts/${id}/comments`
}

export const createComment = async (id: string,
    createCommentRequest: CreateCommentRequest, options?: RequestInit): Promise<BlogPostResponse> => {
  
  return fetcher<BlogPostResponse>(getCreateCommentUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createCommentRequest,)
  }
);}




export const getCreateCommentMutationOptions = <TError = BadRequestResponse | NotFoundResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createComment>>, TError,{id: string;data: CreateCommentRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createComment>>, TError,{id: string;data: CreateCommentRequest}, TContext> => {

const mutationKey = ['createComment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createComment>>, {id: string;data: CreateCommentRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  createComment(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCommentMutationResult = NonNullable<Awaited<ReturnType<typeof createComment>>>
    export type CreateCommentMutationBody = CreateCommentRequest
    export type CreateCommentMutationError = BadRequestResponse | NotFoundResponse

    /**
 * @summary Create Comment
 */
export const useCreateComment = <TError = BadRequestResponse | NotFoundResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createComment>>, TError,{id: string;data: CreateCommentRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createComment>>,
        TError,
        {id: string;data: CreateCommentRequest},
        TContext
      > => {

      const mutationOptions = getCreateCommentMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
