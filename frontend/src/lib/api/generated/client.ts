/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * Blog Post API
 * A comprehensive API for managing blog posts and comments with Firebase Authentication integration.

This API supports:
- Blog post creation, retrieval, and management
- Comment management on blog posts
- User authentication via Firebase Auth
- Pagination and filtering capabilities

## Authentication

All endpoints require Firebase Authentication unless otherwise specified.
Include the Firebase ID token in the Authorization header:

```
Authorization: Bearer <firebase-id-token>
```

 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  BadRequestResponse,
  BlogPostListResponse,
  BlogPostResponse,
  CommentsAcknowledgmentResponse,
  CommentsResponse,
  CreateCommentRequest,
  CreatePostRequest,
  Error,
  GetBlogPostsParams,
  GetPostCommentsParams,
  GetUserFavoritesParams,
  GetUserPostsParams,
  NotFoundResponse,
  UnauthorizedResponse
} from './schemas';

import { customFetch } from '../customFetch';




/**
 * Retrieves a paginated list of published blog posts.

This endpoint supports pagination and returns blog post summaries
optimized for listing views (homepage, archives, etc.).

 * @summary Get Blog Posts
 */
export const getGetBlogPostsUrl = (params?: GetBlogPostsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/posts?${stringifiedParams}` : `/posts`
}

export const getBlogPosts = async (params?: GetBlogPostsParams, options?: RequestInit): Promise<BlogPostListResponse> => {
  
  return customFetch<BlogPostListResponse>(getGetBlogPostsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetBlogPostsQueryKey = (params?: GetBlogPostsParams,) => {
    return [`/posts`, ...(params ? [params]: [])] as const;
    }

    
export const getGetBlogPostsQueryOptions = <TData = Awaited<ReturnType<typeof getBlogPosts>>, TError = BadRequestResponse | Error>(params?: GetBlogPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlogPosts>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBlogPostsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBlogPosts>>> = ({ signal }) => getBlogPosts(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBlogPosts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBlogPostsQueryResult = NonNullable<Awaited<ReturnType<typeof getBlogPosts>>>
export type GetBlogPostsQueryError = BadRequestResponse | Error


export function useGetBlogPosts<TData = Awaited<ReturnType<typeof getBlogPosts>>, TError = BadRequestResponse | Error>(
 params: undefined |  GetBlogPostsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlogPosts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBlogPosts>>,
          TError,
          Awaited<ReturnType<typeof getBlogPosts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBlogPosts<TData = Awaited<ReturnType<typeof getBlogPosts>>, TError = BadRequestResponse | Error>(
 params?: GetBlogPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlogPosts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBlogPosts>>,
          TError,
          Awaited<ReturnType<typeof getBlogPosts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBlogPosts<TData = Awaited<ReturnType<typeof getBlogPosts>>, TError = BadRequestResponse | Error>(
 params?: GetBlogPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlogPosts>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Blog Posts
 */

export function useGetBlogPosts<TData = Awaited<ReturnType<typeof getBlogPosts>>, TError = BadRequestResponse | Error>(
 params?: GetBlogPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlogPosts>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBlogPostsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Creates a new blog post. Requires Firebase Authentication with a non-anonymous user.

Anonymous users are forbidden from creating posts. The author is inferred from the authenticated Firebase user's UID.
Posts may be created as `draft` or `published` depending on the request payload.

 * @summary Create Blog Post
 */
export const getCreateBlogPostUrl = () => {


  

  return `/posts`
}

export const createBlogPost = async (createPostRequest: CreatePostRequest, options?: RequestInit): Promise<BlogPostResponse> => {
  
  return customFetch<BlogPostResponse>(getCreateBlogPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createPostRequest,)
  }
);}




export const getCreateBlogPostMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | Error | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBlogPost>>, TError,{data: CreatePostRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createBlogPost>>, TError,{data: CreatePostRequest}, TContext> => {

const mutationKey = ['createBlogPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBlogPost>>, {data: CreatePostRequest}> = (props) => {
          const {data} = props ?? {};

          return  createBlogPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBlogPostMutationResult = NonNullable<Awaited<ReturnType<typeof createBlogPost>>>
    export type CreateBlogPostMutationBody = CreatePostRequest
    export type CreateBlogPostMutationError = BadRequestResponse | UnauthorizedResponse | Error | Error

    /**
 * @summary Create Blog Post
 */
export const useCreateBlogPost = <TError = BadRequestResponse | UnauthorizedResponse | Error | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBlogPost>>, TError,{data: CreatePostRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createBlogPost>>,
        TError,
        {data: CreatePostRequest},
        TContext
      > => {

      const mutationOptions = getCreateBlogPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieves detailed information about a specific blog post by its ID.

Returns the complete blog post including content, metadata, and author information.

 * @summary Get Single Blog Post
 */
export const getGetBlogPostByIdUrl = (id: string,) => {


  

  return `/posts/${id}`
}

export const getBlogPostById = async (id: string, options?: RequestInit): Promise<BlogPostResponse> => {
  
  return customFetch<BlogPostResponse>(getGetBlogPostByIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetBlogPostByIdQueryKey = (id?: string,) => {
    return [`/posts/${id}`] as const;
    }

    
export const getGetBlogPostByIdQueryOptions = <TData = Awaited<ReturnType<typeof getBlogPostById>>, TError = NotFoundResponse | Error>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlogPostById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBlogPostByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBlogPostById>>> = ({ signal }) => getBlogPostById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBlogPostById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBlogPostByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getBlogPostById>>>
export type GetBlogPostByIdQueryError = NotFoundResponse | Error


export function useGetBlogPostById<TData = Awaited<ReturnType<typeof getBlogPostById>>, TError = NotFoundResponse | Error>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlogPostById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBlogPostById>>,
          TError,
          Awaited<ReturnType<typeof getBlogPostById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBlogPostById<TData = Awaited<ReturnType<typeof getBlogPostById>>, TError = NotFoundResponse | Error>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlogPostById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBlogPostById>>,
          TError,
          Awaited<ReturnType<typeof getBlogPostById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBlogPostById<TData = Awaited<ReturnType<typeof getBlogPostById>>, TError = NotFoundResponse | Error>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlogPostById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Single Blog Post
 */

export function useGetBlogPostById<TData = Awaited<ReturnType<typeof getBlogPostById>>, TError = NotFoundResponse | Error>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlogPostById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBlogPostByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Updates an existing blog post by its ID. Requires authentication.

Only the author of the post or users with admin privileges can update a post.
Partial updates are supported - only provided fields will be updated.

 * @summary Update Blog Post
 */
export const getUpdateBlogPostUrl = (id: string,) => {


  

  return `/posts/${id}`
}

export const updateBlogPost = async (id: string,
    createPostRequest: CreatePostRequest, options?: RequestInit): Promise<BlogPostResponse> => {
  
  return customFetch<BlogPostResponse>(getUpdateBlogPostUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createPostRequest,)
  }
);}




export const getUpdateBlogPostMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | Error | NotFoundResponse | Error | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBlogPost>>, TError,{id: string;data: CreatePostRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBlogPost>>, TError,{id: string;data: CreatePostRequest}, TContext> => {

const mutationKey = ['updateBlogPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBlogPost>>, {id: string;data: CreatePostRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateBlogPost(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBlogPostMutationResult = NonNullable<Awaited<ReturnType<typeof updateBlogPost>>>
    export type UpdateBlogPostMutationBody = CreatePostRequest
    export type UpdateBlogPostMutationError = BadRequestResponse | UnauthorizedResponse | Error | NotFoundResponse | Error | Error

    /**
 * @summary Update Blog Post
 */
export const useUpdateBlogPost = <TError = BadRequestResponse | UnauthorizedResponse | Error | NotFoundResponse | Error | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBlogPost>>, TError,{id: string;data: CreatePostRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBlogPost>>,
        TError,
        {id: string;data: CreatePostRequest},
        TContext
      > => {

      const mutationOptions = getUpdateBlogPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Deletes a blog post by its ID. Requires authentication.

Only the author of the post or users with admin privileges can delete a post.
This action is irreversible.

 * @summary Delete Blog Post
 */
export const getDeleteBlogPostUrl = (id: string,) => {


  

  return `/posts/${id}`
}

export const deleteBlogPost = async (id: string, options?: RequestInit): Promise<null> => {
  
  return customFetch<null>(getDeleteBlogPostUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteBlogPostMutationOptions = <TError = UnauthorizedResponse | Error | NotFoundResponse | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBlogPost>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteBlogPost>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteBlogPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBlogPost>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteBlogPost(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBlogPostMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBlogPost>>>
    
    export type DeleteBlogPostMutationError = UnauthorizedResponse | Error | NotFoundResponse | Error

    /**
 * @summary Delete Blog Post
 */
export const useDeleteBlogPost = <TError = UnauthorizedResponse | Error | NotFoundResponse | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBlogPost>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteBlogPost>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteBlogPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieves all comments for a specific blog post via standard REST API.

**Response Pattern:**
- HTTP Response: Direct JSON response with comments array
- No WebSocket involvement for this endpoint

Comments are returned in chronological order (oldest first).
This endpoint is public and does not require authentication.

 * @summary Get Post Comments
 */
export const getGetPostCommentsUrl = (id: string,
    params?: GetPostCommentsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/posts/${id}/comments?${stringifiedParams}` : `/posts/${id}/comments`
}

export const getPostComments = async (id: string,
    params?: GetPostCommentsParams, options?: RequestInit): Promise<CommentsResponse> => {
  
  return customFetch<CommentsResponse>(getGetPostCommentsUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetPostCommentsQueryKey = (id?: string,
    params?: GetPostCommentsParams,) => {
    return [`/posts/${id}/comments`, ...(params ? [params]: [])] as const;
    }

    
export const getGetPostCommentsQueryOptions = <TData = Awaited<ReturnType<typeof getPostComments>>, TError = NotFoundResponse | Error>(id: string,
    params?: GetPostCommentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostComments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPostCommentsQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPostComments>>> = ({ signal }) => getPostComments(id,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPostComments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPostCommentsQueryResult = NonNullable<Awaited<ReturnType<typeof getPostComments>>>
export type GetPostCommentsQueryError = NotFoundResponse | Error


export function useGetPostComments<TData = Awaited<ReturnType<typeof getPostComments>>, TError = NotFoundResponse | Error>(
 id: string,
    params: undefined |  GetPostCommentsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostComments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPostComments>>,
          TError,
          Awaited<ReturnType<typeof getPostComments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPostComments<TData = Awaited<ReturnType<typeof getPostComments>>, TError = NotFoundResponse | Error>(
 id: string,
    params?: GetPostCommentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostComments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPostComments>>,
          TError,
          Awaited<ReturnType<typeof getPostComments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPostComments<TData = Awaited<ReturnType<typeof getPostComments>>, TError = NotFoundResponse | Error>(
 id: string,
    params?: GetPostCommentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostComments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Post Comments
 */

export function useGetPostComments<TData = Awaited<ReturnType<typeof getPostComments>>, TError = NotFoundResponse | Error>(
 id: string,
    params?: GetPostCommentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostComments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPostCommentsQueryOptions(id,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Creates a new comment on a specific blog post. Requires authentication.

**Response Pattern:**
- HTTP Response: Acknowledgment response only (no comment data)
- WebSocket Broadcast: New comment data is broadcast to all connected clients via API Gateway WebSocket

**WebSocket Message Format (sent to all clients after successful creation):**
```json
{
  "type": "NEW_COMMENT",
  "postId": "string",
  "comment": {
    "id": "string",
    "content": "string",
    "authorId": "string", 
    "authorName": "string",
    "createdAt": "timestamp"
  }
}
```

The userId will be automatically set based on the authenticated user's Firebase UID.
Comments are moderated and may not appear immediately.

 * @summary Create Comment
 */
export const getCreateCommentUrl = (id: string,) => {


  

  return `/posts/${id}/comments`
}

export const createComment = async (id: string,
    createCommentRequest: CreateCommentRequest, options?: RequestInit): Promise<CommentsAcknowledgmentResponse> => {
  
  return customFetch<CommentsAcknowledgmentResponse>(getCreateCommentUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createCommentRequest,)
  }
);}




export const getCreateCommentMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | Error | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createComment>>, TError,{id: string;data: CreateCommentRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createComment>>, TError,{id: string;data: CreateCommentRequest}, TContext> => {

const mutationKey = ['createComment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createComment>>, {id: string;data: CreateCommentRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  createComment(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCommentMutationResult = NonNullable<Awaited<ReturnType<typeof createComment>>>
    export type CreateCommentMutationBody = CreateCommentRequest
    export type CreateCommentMutationError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | Error | Error

    /**
 * @summary Create Comment
 */
export const useCreateComment = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | Error | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createComment>>, TError,{id: string;data: CreateCommentRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createComment>>,
        TError,
        {id: string;data: CreateCommentRequest},
        TContext
      > => {

      const mutationOptions = getCreateCommentMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Marks a post as a favorite for the current user. Requires Firebase Authentication.

Works for both anonymous and authenticated users. Anonymous users must include a valid anonymous Firebase ID token.

 * @summary Add Post to Favorites
 */
export const getFavoritePostUrl = (id: string,) => {


  

  return `/posts/${id}/favorite`
}

export const favoritePost = async (id: string, options?: RequestInit): Promise<null> => {
  
  return customFetch<null>(getFavoritePostUrl(id),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getFavoritePostMutationOptions = <TError = UnauthorizedResponse | NotFoundResponse | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof favoritePost>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof favoritePost>>, TError,{id: string}, TContext> => {

const mutationKey = ['favoritePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof favoritePost>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  favoritePost(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FavoritePostMutationResult = NonNullable<Awaited<ReturnType<typeof favoritePost>>>
    
    export type FavoritePostMutationError = UnauthorizedResponse | NotFoundResponse | Error

    /**
 * @summary Add Post to Favorites
 */
export const useFavoritePost = <TError = UnauthorizedResponse | NotFoundResponse | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof favoritePost>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof favoritePost>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getFavoritePostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Removes a post from the current user's favorites. Requires Firebase Authentication.

Works for both anonymous and authenticated users.

 * @summary Remove Post from Favorites
 */
export const getUnfavoritePostUrl = (id: string,) => {


  

  return `/posts/${id}/favorite`
}

export const unfavoritePost = async (id: string, options?: RequestInit): Promise<null> => {
  
  return customFetch<null>(getUnfavoritePostUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getUnfavoritePostMutationOptions = <TError = UnauthorizedResponse | NotFoundResponse | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unfavoritePost>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof unfavoritePost>>, TError,{id: string}, TContext> => {

const mutationKey = ['unfavoritePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof unfavoritePost>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  unfavoritePost(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UnfavoritePostMutationResult = NonNullable<Awaited<ReturnType<typeof unfavoritePost>>>
    
    export type UnfavoritePostMutationError = UnauthorizedResponse | NotFoundResponse | Error

    /**
 * @summary Remove Post from Favorites
 */
export const useUnfavoritePost = <TError = UnauthorizedResponse | NotFoundResponse | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unfavoritePost>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof unfavoritePost>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getUnfavoritePostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieves a paginated list of blog posts owned by the specified user (identified by Firebase `uid`).

Requires Firebase Authentication. The caller must be the same user as `{uid}` or have admin permissions.

Supports filtering by `status`. When `status` is omitted, returns all posts for the user
(both `published` and `draft`).

 * @summary Get Posts For User
 */
export const getGetUserPostsUrl = (uid: string,
    params?: GetUserPostsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/users/${uid}/posts?${stringifiedParams}` : `/users/${uid}/posts`
}

export const getUserPosts = async (uid: string,
    params?: GetUserPostsParams, options?: RequestInit): Promise<BlogPostListResponse> => {
  
  return customFetch<BlogPostListResponse>(getGetUserPostsUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetUserPostsQueryKey = (uid?: string,
    params?: GetUserPostsParams,) => {
    return [`/users/${uid}/posts`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUserPostsQueryOptions = <TData = Awaited<ReturnType<typeof getUserPosts>>, TError = BadRequestResponse | UnauthorizedResponse | Error | NotFoundResponse | Error>(uid: string,
    params?: GetUserPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserPosts>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserPostsQueryKey(uid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserPosts>>> = ({ signal }) => getUserPosts(uid,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserPosts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserPostsQueryResult = NonNullable<Awaited<ReturnType<typeof getUserPosts>>>
export type GetUserPostsQueryError = BadRequestResponse | UnauthorizedResponse | Error | NotFoundResponse | Error


export function useGetUserPosts<TData = Awaited<ReturnType<typeof getUserPosts>>, TError = BadRequestResponse | UnauthorizedResponse | Error | NotFoundResponse | Error>(
 uid: string,
    params: undefined |  GetUserPostsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserPosts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserPosts>>,
          TError,
          Awaited<ReturnType<typeof getUserPosts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserPosts<TData = Awaited<ReturnType<typeof getUserPosts>>, TError = BadRequestResponse | UnauthorizedResponse | Error | NotFoundResponse | Error>(
 uid: string,
    params?: GetUserPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserPosts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserPosts>>,
          TError,
          Awaited<ReturnType<typeof getUserPosts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserPosts<TData = Awaited<ReturnType<typeof getUserPosts>>, TError = BadRequestResponse | UnauthorizedResponse | Error | NotFoundResponse | Error>(
 uid: string,
    params?: GetUserPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserPosts>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Posts For User
 */

export function useGetUserPosts<TData = Awaited<ReturnType<typeof getUserPosts>>, TError = BadRequestResponse | UnauthorizedResponse | Error | NotFoundResponse | Error>(
 uid: string,
    params?: GetUserPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserPosts>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserPostsQueryOptions(uid,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieves a paginated list of posts favorited by the specified user (Firebase `uid`).

Requires Firebase Authentication. The caller must be the same user as `{uid}` or have admin permissions.

 * @summary Get Favorite Posts For User
 */
export const getGetUserFavoritesUrl = (uid: string,
    params?: GetUserFavoritesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/users/${uid}/favorites?${stringifiedParams}` : `/users/${uid}/favorites`
}

export const getUserFavorites = async (uid: string,
    params?: GetUserFavoritesParams, options?: RequestInit): Promise<BlogPostListResponse> => {
  
  return customFetch<BlogPostListResponse>(getGetUserFavoritesUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetUserFavoritesQueryKey = (uid?: string,
    params?: GetUserFavoritesParams,) => {
    return [`/users/${uid}/favorites`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUserFavoritesQueryOptions = <TData = Awaited<ReturnType<typeof getUserFavorites>>, TError = BadRequestResponse | UnauthorizedResponse | Error | NotFoundResponse | Error>(uid: string,
    params?: GetUserFavoritesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserFavoritesQueryKey(uid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserFavorites>>> = ({ signal }) => getUserFavorites(uid,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserFavoritesQueryResult = NonNullable<Awaited<ReturnType<typeof getUserFavorites>>>
export type GetUserFavoritesQueryError = BadRequestResponse | UnauthorizedResponse | Error | NotFoundResponse | Error


export function useGetUserFavorites<TData = Awaited<ReturnType<typeof getUserFavorites>>, TError = BadRequestResponse | UnauthorizedResponse | Error | NotFoundResponse | Error>(
 uid: string,
    params: undefined |  GetUserFavoritesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserFavorites>>,
          TError,
          Awaited<ReturnType<typeof getUserFavorites>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserFavorites<TData = Awaited<ReturnType<typeof getUserFavorites>>, TError = BadRequestResponse | UnauthorizedResponse | Error | NotFoundResponse | Error>(
 uid: string,
    params?: GetUserFavoritesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserFavorites>>,
          TError,
          Awaited<ReturnType<typeof getUserFavorites>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserFavorites<TData = Awaited<ReturnType<typeof getUserFavorites>>, TError = BadRequestResponse | UnauthorizedResponse | Error | NotFoundResponse | Error>(
 uid: string,
    params?: GetUserFavoritesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Favorite Posts For User
 */

export function useGetUserFavorites<TData = Awaited<ReturnType<typeof getUserFavorites>>, TError = BadRequestResponse | UnauthorizedResponse | Error | NotFoundResponse | Error>(
 uid: string,
    params?: GetUserFavoritesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserFavoritesQueryOptions(uid,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




